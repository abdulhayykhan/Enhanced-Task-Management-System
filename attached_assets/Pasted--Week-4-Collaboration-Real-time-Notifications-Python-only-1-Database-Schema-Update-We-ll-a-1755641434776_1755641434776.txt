ðŸš€ Week 4 â€“ Collaboration & Real-time Notifications (Python-only)
1. Database Schema Update

Weâ€™ll allow tasks to be shared with multiple users.

Update models.py:

from sqlalchemy import Column, Integer, String, Date, ForeignKey, Table
from sqlalchemy.orm import relationship
from database import Base

# Association table for many-to-many (task <-> shared users)
task_shares = Table(
    "task_shares", Base.metadata,
    Column("task_id", Integer, ForeignKey("tasks.id")),
    Column("user_id", Integer, ForeignKey("users.id"))
)

class Task(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(String, nullable=True)
    status = Column(String, default="Pending")
    due_date = Column(Date, nullable=True)
    owner_id = Column(Integer, ForeignKey("users.id"))

    owner = relationship("User", back_populates="owned_tasks")
    shared_with = relationship("User", secondary=task_shares, back_populates="shared_tasks")

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    password = Column(String)

    owned_tasks = relationship("Task", back_populates="owner")
    shared_tasks = relationship("Task", secondary=task_shares, back_populates="shared_with")


Run:

alembic revision --autogenerate -m "add task sharing"
alembic upgrade head


(or drop/recreate if no migrations yet).

2. API Endpoints for Sharing

In main.py:

@app.post("/tasks/{task_id}/share")
def share_task(task_id: int, username: str = Form(...), db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    task = crud.get_task(db, task_id)
    if task.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to share this task")

    user_to_share = db.query(User).filter(User.username == username).first()
    if not user_to_share:
        raise HTTPException(status_code=404, detail="User not found")

    if user_to_share not in task.shared_with:
        task.shared_with.append(user_to_share)
        db.commit()
    return RedirectResponse(f"/tasks/{task_id}", status_code=303)

@app.get("/tasks/shared")
def get_shared_tasks(request: Request, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    tasks = current_user.shared_tasks
    return templates.TemplateResponse("index.html", {"request": request, "tasks": tasks, "q": None, "status": None})

3. Real-time Notifications with WebSockets

FastAPI supports WebSockets. Weâ€™ll notify users when:

A task is shared with them

A taskâ€™s status is updated

Notification model (models.py):
from sqlalchemy import DateTime, func

class Notification(Base):
    __tablename__ = "notifications"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    message = Column(String)
    created_at = Column(DateTime, default=func.now())

WebSocket Manager (notifications.py)
from typing import Dict
from fastapi import WebSocket

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[int, WebSocket] = {}

    async def connect(self, user_id: int, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[user_id] = websocket

    def disconnect(self, user_id: int):
        self.active_connections.pop(user_id, None)

    async def send_personal_message(self, message: str, user_id: int):
        if user_id in self.active_connections:
            await self.active_connections[user_id].send_text(message)

manager = ConnectionManager()

WebSocket Route (main.py)
from fastapi import WebSocket, WebSocketDisconnect
from notifications import manager

@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: int):
    await manager.connect(user_id, websocket)
    try:
        while True:
            await websocket.receive_text()  # keep connection open
    except WebSocketDisconnect:
        manager.disconnect(user_id)

Trigger Notifications

When sharing/updating tasks:

from models import Notification

def notify_user(db, user_id: int, message: str):
    note = Notification(user_id=user_id, message=message)
    db.add(note)
    db.commit()
    # also push via websocket
    import asyncio
    asyncio.create_task(manager.send_personal_message(message, user_id))


Example (in /share route):

notify_user(db, user_to_share.id, f"A task '{task.title}' was shared with you")

4. Frontend Integration (Jinja2)

In base.html, add notifications sidebar:

<div class="alert alert-info" id="notifications"></div>
<script>
  const userId = "{{ request.cookies.get('user_id') }}";
  if (userId) {
    const ws = new WebSocket(`ws://${window.location.host}/ws/${userId}`);
    ws.onmessage = (event) => {
      const box = document.getElementById("notifications");
      box.innerHTML = event.data;
    };
  }
</script>

âœ… Deliverables for Week 4

Task sharing between users (owner â†’ shared users).

Real-time notifications with WebSockets.

Notification persistence (DB + WebSocket).

Frontend integration (notifications appear instantly).