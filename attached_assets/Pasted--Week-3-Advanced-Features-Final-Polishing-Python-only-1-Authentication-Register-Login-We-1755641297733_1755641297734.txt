ðŸš€ Week 3 â€“ Advanced Features & Final Polishing (Python-only)
1. Authentication (Register/Login)

Weâ€™ll keep it simple with username + password (hashed) and store users in the database.

Update Database Model (models.py)
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    password = Column(String)  # store hashed password

Auth Utils (auth.py)
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
import jwt, datetime

SECRET_KEY = "SECRET123"  # replace with env var in production
ALGORITHM = "HS256"

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def hash_password(password: str):
    return pwd_context.hash(password)

def verify_password(plain, hashed):
    return pwd_context.verify(plain, hashed)

def create_access_token(data: dict, expires_delta: int = 60):
    to_encode = data.copy()
    expire = datetime.datetime.utcnow() + datetime.timedelta(minutes=expires_delta)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def decode_access_token(token: str):
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except:
        raise HTTPException(status_code=401, detail="Invalid token")

User Routes (main.py)
from fastapi import Form
from auth import hash_password, verify_password, create_access_token, decode_access_token
from models import User

@app.get("/register")
def register_page(request: Request):
    return templates.TemplateResponse("form.html", {"request": request, "task": None})

@app.post("/register")
def register_user(username: str = Form(...), password: str = Form(...), db: Session = Depends(get_db)):
    user = User(username=username, password=hash_password(password))
    db.add(user)
    db.commit()
    return RedirectResponse("/login", status_code=303)

@app.get("/login")
def login_page(request: Request):
    return templates.TemplateResponse("form.html", {"request": request, "task": None})

@app.post("/login")
def login_user(username: str = Form(...), password: str = Form(...), db: Session = Depends(get_db)):
    user = db.query(User).filter(User.username == username).first()
    if not user or not verify_password(password, user.password):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token({"sub": user.username})
    response = RedirectResponse("/", status_code=303)
    response.set_cookie(key="access_token", value=token, httponly=True)
    return response


ðŸ‘‰ You now have basic authentication with sessions.
Users must log in before accessing tasks (wrap routes with Depends() that checks cookie).

2. Search & Filters

Update main.py:

@app.get("/")
def read_root(request: Request, q: str = None, status: str = None, db: Session = Depends(get_db)):
    query = db.query(models.Task)
    if q:
        query = query.filter(models.Task.title.contains(q) | models.Task.description.contains(q))
    if status:
        query = query.filter(models.Task.status == status)
    tasks = query.all()
    return templates.TemplateResponse("index.html", {"request": request, "tasks": tasks, "q": q, "status": status})


Update index.html (add search + filter form above task table):

<form method="get" class="mb-3">
  <input type="text" name="q" placeholder="Search..." value="{{ q or '' }}" class="form-control mb-2">
  <select name="status" class="form-control mb-2">
    <option value="">All</option>
    <option value="Pending" {% if status == "Pending" %}selected{% endif %}>Pending</option>
    <option value="In Progress" {% if status == "In Progress" %}selected{% endif %}>In Progress</option>
    <option value="Completed" {% if status == "Completed" %}selected{% endif %}>Completed</option>
  </select>
  <button type="submit" class="btn btn-info">Filter</button>
</form>

3. Task Progress Tracking

Add a progress bar at the top of index.html:

{% set completed = tasks | selectattr("status", "equalto", "Completed") | list %}
{% set total = tasks|length %}
{% set progress = (completed|length / total * 100) if total > 0 else 0 %}

<div class="progress mb-3">
  <div class="progress-bar bg-success" role="progressbar" style="width: {{ progress }}%;">
    {{ progress|round(1) }}% Completed
  </div>
</div>

4. Optimization & Testing

Add SQL indexes on status and due_date fields in your Task model.

Write basic Pytest tests for APIs:

pip install pytest httpx


test_main.py

from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_home():
    res = client.get("/")
    assert res.status_code == 200


âœ… Deliverables for Week 3:

User register/login system with password hashing + tokens

Search bar and status filter

Progress tracking with a Bootstrap progress bar

Basic tests and query optimizations